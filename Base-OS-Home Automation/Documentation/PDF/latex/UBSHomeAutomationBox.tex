% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsfrench{\renewcommand{\figurename}{Fig. }}
\addto\captionsfrench{\renewcommand{\tablename}{Tableau }}
\SetupFloatingEnvironment{literal-block}{name=Code source }



\title{UBS "Documentation du Mini projet : Home Automation Box"}
\date{02 January 2019}
\release{0.1}
\author{JAVIER LÓPEZ José Antonio}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Version}
\setcounter{tocdepth}{2}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}





\chapter{Introduction}
\label{introduction:bienvenue-dans-la-documentation-d-ubs-home-automation-box}\label{introduction:introduction}\label{introduction::doc}
Le but de cette page sera d’expliquer tous les démarches pour créer une distribution linux pour la machine cible ``humingoboard HB2 Gate 1.4''. Ainsi que la détection de l’humidité et la temperature  de l'environnement en utilisant le capteur ``Adafruit Si70212''.

L'outil principal utilisé dans l'élaboration du projet a éte l'outil ``Yocto Project''. Puisqu'il est ‘‘open source’’ et permet aux développeurs de créer des systèmes personnalisés basés sur Linux quelle que soit l’architecture matérielle. La distribution utilisée du Yocto project a été ‘‘Poky’’ car elle contient le système de construction OpenEmbedded (BitBake et OpenEmbedded Core) ainsi qu'un ensemble de ‘‘metadata’’, ce qui nous permet de faire notre propre distribution. La fonction principale  qui a été utilisé de la distrbution ``Poky'' a été BitBake puisqu’il est le cœur du système de compilation OpenEmbedded et il est responsable de l'analyse des ‘‘metadata’’, pour générer une liste de tâches qui seront exécutés.

Les étapes qui ont été suivies pour le développement du projet sont alors :

{\hspace*{\fill}\includegraphics[scale=0.6]{{Diagrammedeflux}.png}\hspace*{\fill}}


\chapter{Développement}
\label{developpement::doc}\label{developpement:developpement}

\section{Configuration du système pour la machine cible à utiliser}
\label{developpement:configuration-du-systeme-pour-la-machine-cible-a-utiliser}
Un layer est un dossier qui contient des ensembles d'instructions, ils indiquent au système de construction OpenEmbedded ce qu'il faut faire pour utiliser la machine cible ``Humingoboard HB2 Gate 1.4''.

La machine cible utilise le système Freescale i.MX6 System-on-a-Chip. Le layer BSP de ce SoC est le ‘‘méta-freescale’’, il contient par exemple des bibliothèques GPU, VPU, l’u-boot et Linux Kernel. Le layer ‘‘meta-solidrun’’, ce lui qui donne le support nécessaire pour les plateformes SolidRun's iMX6.

Pour ajouter les layers, il faudra les télécharger, les installer, les placer sur la même branche, initialiser l'environnement OpenEmbedded et finalement les attacher à l'aide de la commande Bitbake. Les lignes de commandes suivantes ont été utilisées :

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone git ://git.yoctoproject.org/meta\PYGZhy{}freescale
\PYGZdl{} \PYG{n+nb}{cd} meta\PYGZhy{}freescale
\PYGZdl{} git checkout \PYGZhy{}b rocko origin/rocko
\PYGZdl{} \PYG{n+nb}{cd} ..
\PYGZdl{} git clone git://github.com/SolidRun/meta\PYGZhy{}solidrun\PYGZhy{}arm\PYGZhy{}imx6.git
\PYGZdl{} \PYG{n+nb}{cd} meta\PYGZhy{}solidrun\PYGZhy{}arm\PYGZhy{}imx6
\PYGZdl{} git checkout \PYGZhy{}b rocko origin/rocko
\PYGZdl{} \PYG{n+nb}{cd} ..
\PYGZdl{} \PYG{n+nb}{source} oe\PYGZhy{}init\PYGZhy{}build \PYGZhy{}env
\PYGZdl{} bitbake\PYGZhy{}layers add\PYGZhy{}layer ../meta\PYGZhy{}freescale
\PYGZdl{} bitbake\PYGZhy{}layers add\PYGZhy{}layer ../meta\PYGZhy{}solidrun\PYGZhy{}arm\PYGZhy{}imx6
\end{Verbatim}


\section{Creation et configuration d’un layer et une recette image}
\label{developpement:creation-et-configuration-dun-layer-et-une-recette-image}
L'idée du projet est de générer notre propre distribution avec notre propre configuration, il faut donc créer une recette de type image. Nous partons de la basse que nous avons déjà initialisé l’environnement (source oe-init-build-env) et nous somme sur le dossier /poky. Les lignes de commandes suivantes ont été exécutées :

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} yocto\PYGZhy{}layer create ubs\PYGZhy{}homeautomation
Please enter the layer priority you\PYGZsq{}d like to use for the layer: [default: 6]
Would you like to have an example recipe created? (y/n) [default: n] n
Would you like to have an example bbappend file created? (y/n) [default: n] n
\PYGZdl{}cd ../meta\PYGZhy{}ubs\PYGZhy{}homeautomation
\PYGZdl{}mkdir \PYGZhy{}p recipes\PYGZhy{}core/images
\PYGZdl{}cd recipes\PYGZhy{}core/images
\PYGZdl{}touch image\PYGZhy{}ubs\PYGZhy{}homeautomation.bb
\end{Verbatim}

Les commandes précédentes nous permettent de créer notre propre layer sans exemples. Nous avons aussi créé le dossier ‘‘recipes-core/image’’ pour indiquer quelle recette sera compilée. Puis nous avons créé un fichier ``image-ubs-homeautomation.bb'' ce qui corresponde à notre fichier recette.

Finalement une série de modifications a été pris en compte afin de personnaliser notre distribution. Pour modifier tous les fichiers du projet, l’éditeur nano a été utilisé, puisqu’il est considéré comme un des éditeurs de texte plus simple à utiliser. La commande qui nous permet de modifier notre recette est alors :

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}nano core\PYGZhy{}image\PYGZhy{}minimal.bb
\end{Verbatim}

Une fois en mode édition, les critères suivants ont été ajoutés :
\begin{itemize}
\item {} 
Ajout d’une image qui nous permet le démarrage de notre machine cible.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
include recipes\PYGZhy{}core/images/core\PYGZhy{}image\PYGZhy{}minimal.bb
\end{Verbatim}
\end{quote}

\item {} 
Ajout d’un service qui nous permet la connexion à distance afin de mettre à jour le système ou réaliser différentes manipulations.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
IMAGE\PYGZus{}FEATURES +\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}ssh\PYGZhy{}server\PYGZhy{}dropbear\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Ajout d’un service qui nous permet d’utiliser les GPIO de la carte, afin de se communiquer via I2C. Nous pourrions de cette façon établir une connexion avec le capteur ``Adafruit Si7021''.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
IMAGE\PYGZus{}INSTALL +\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{} i2c\PYGZhy{}tools\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Ajout d’un compte utilisateur (``user : ubs'' et ``password:ssi''), en utilisant la classe extra user.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
inherit extrausers
\PYG{n+nv}{EXTRA\PYGZus{}USERS\PYGZus{}PARAMS} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}useradd \PYGZhy{}P \PYGZsq{}ssi\PYGZsq{} ubs;\PYGZdq{}}
\end{Verbatim}
\end{quote}

\end{itemize}

Un fois la configuration a été finalisé sur l’éditeur nano, les commandes ‘‘ctrl+o’’ et ‘‘ctrl+x’’ nous permettent d’enregistrer le fichier et de sortir de l’interface d’édition.


\section{Configuration du local.conf:}
\label{developpement:configuration-du-local-conf}
Pour optimiser et exécuter la compilation de notre distribution certains modifications sur le fichier ‘‘local.conf’’ ont été nécessaires. Les configurations suivantes ont été réalisées :
\begin{itemize}
\item {} 
La sélection d'une machine est une configuration nécessaire pour construire les paquets de l'architecture sélectionnée. Pour faire une compilation de notre machine cible, l'option ``solidrun-imx6'' doit être utilisée. Cependant l'option ‘‘qemuarm’’ a aussi été utilisée, afin de tester l'image sous un environnement virtuelle.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
MACHINE ?\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}qemuarm\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}MACHINE ??= \PYGZdq{}solidrun\PYGZhy{}imx6\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Afin d’optimiser la compilation, le plus important est la suppression des sources après la compilation. L’option suivante a donc été ajoutée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
INHERIT +\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}rm\PYGZus{}work\PYGZdq{}}a
\end{Verbatim}
\end{quote}

\item {} 
Nous pouvons exécuter la compilation de forme parallèle, la diminution de temps est par suite considérable. Cependant le nombre de tâches parallèles à exécuter à une relation avec le nombre de processeurs disponible sur l’ordinateur. L’option suivante a donc été ajoutée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
PARALLEL\PYGZus{}MAKE ?\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}j 4\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Comme précédemment, nous pouvons définir le nombre de tâches que BitBake peut exécuter en parallèle. Ce processus permet à BitBake de diviser la construction des paquets en plusieurs tâches. L'option suivante a donc été ajoutée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
BB\PYGZus{}NUMBER\PYGZus{}THREADS ?\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}4\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Nous avons choisi l’utilisation du Package Management System, puisqu'est un système de gestion de paquets léger conçu pour les systèmes embarqués. Le format IPK a l’avantage d’être très compact, bien plus que les deux autres formats RPM et DEB. Ce format permet aussi l'installation de nouveaux paquets, la mise à jour ou la suppression de paquets existants, l'interrogation des dépôts de paquets pour les paquets disponibles et la liste des paquets déjà installés. La configuration suivante a donc été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
PACKAGE\PYGZus{}CLASSES ?\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}package\PYGZus{}ipk\PYGZdq{}}
\end{Verbatim}
\end{quote}

\item {} 
Pour exécuter une application au démarrage, l’utilisation de Systemd est nécessaire. Systemd offre une meilleure gestion des services, il permet le chargement en parallèle des services au démarrage et il peut aussi diminuer le temps de démarrage du système. La configuration suivante a alors été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{DISTRO\PYGZus{}FEATURES\PYGZus{}append} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{} systemd\PYGZdq{}}
VIRTUAL\PYGZhy{}RUNTIME\PYGZus{}init\PYGZus{}manager \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}systemd\PYGZdq{}}
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Afin d’éviter des problèmes au démarrage, nous avons empêché l'activation automatique de la fonction de distribution SysVinit, aussi nous avons supprimé tous les scripts SysVinit redondants, en utilisant la configuration suivante :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{DISTRO\PYGZus{}FEATURES\PYGZus{}BACKFILL\PYGZus{}CONSIDERED} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}sysvinit\PYGZdq{}}
VIRTUAL\PYGZhy{}RUNTIME\PYGZus{}initscripts \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}
\end{quote}
\end{quote}
\begin{itemize}
\item {} 
Finalement pour accélérer les compilations futures, nous avons utilisé la fonction L\_DIR, puisque la fonction définit où les paquets téléchargés sont stockées. Si nous faisons une autre compilation, il n'essaiera pas de télécharger un paquet s'il est déjà présent. La configuration suivante a donc été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
DL\PYGZus{}DIR ?\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{TOPDIR}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{/downloads}\PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}
\end{quote}

\end{itemize}

Les réglages ont été effectués à l'aide de l'éditeur Nano. Cependant, n'importe quel éditeur peut être utilisé pour ajouter les paramètres.


\section{Compilation et test de l’image}
\label{developpement:compilation-et-test-de-limage}

\subsection{Compilation de l'image}
\label{developpement:compilation-de-l-image}
Nous partons de la basse que nous avons déjà initialisé l’environnement (source oe-init-build -env) et nous somme sur le dossier poky/build/. Pour exécuter la compilation de notre image, la commande suivante a été utilisée :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}b}itbake core\PYGZhy{}image\PYGZhy{}ubs\PYGZhy{}homeautomation
\end{Verbatim}

\begin{notice}{note}{Note:}
Le processus de compilation peut prendre entre 5 et 6 heures, mais cela peut dépendre de la configuration effectuée dans le fichier `'local.conf'' ainsi que des caractéristiques de la machine hôte.
\end{notice}


\subsection{Test de l'image sur QEMU}
\label{developpement:test-de-l-image-sur-qemu}
Lorsque le processus de compilation est terminé, l'image du système est prête et peut être utilisée. Les premiers tests fonctionnels ont donc été effectués :
\begin{itemize}
\item {} 
Le logiciel QEMU a été utilisé puisqu’il permet d’émuler une architecture et d’exécuter un ou plusieurs systèmes d’exploitation. Tester notre distribution sur une machine virtuelle nous permet d'identifier d'éventuelles erreurs avant que le logiciel soit installé sur la machine cible. Pour exécuter l’environnement virtuelle, la commande suivante a été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}runqemu qemuarm
\end{Verbatim}
\end{quote}

\item {} 
Une fois l'environnement a été initialisé, le nom d'utilisateur et le mot de passe ont été saisis (utilisateur : ubs, mot de passe : ssi).
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)} 2.4.4 qemuarm tty
qemuarm login: ubs
Password: ssi
qemuarm:\PYGZti{}\PYGZdl{}
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Nous pouvons donc valider que le compte utilisateur fonction correctement.
\end{quote}
\begin{itemize}
\item {} 
Nous pouvons aussi tester la connexion via SSH. L'adresse IP de la machine hôte est 192.168.10.2, l'adresse IP de la machine cible doit alors être configurée pour que les deux machines soient sur le même sous-réseau. Les commandes suivantes ont donc été utilisées :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)} 2.4.4 qemuarm tty
qemuarm login: root
root@qemuarm:\PYGZti{}\PYGZsh{}ifconfig eth0 192.168.10.1
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Ceci a configuré notre machine cible avec l'adresse IP 192.168.10.1. La communication et le partage d'information sera donc plus facile, puisque les deux machines sont dans le même sous-réseau,
\end{quote}
\begin{itemize}
\item {} 
Puis nous avons établi un pont de communication entre la machine cible et la machine hôte. Sur le terminal de la machine hôte, les commandes suivantes ont été utilisées :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}sudo ssh root@192.168.10.1
The authenticity of host \PYGZsq{}192.168.10.1 (192.168.10.1)\PYGZsq{} can\PYGZsq{}t be established.
RSA key fingerprint is SHA256:1SIJ/499OrkZOS/VB+bs+TVRF9XStGhso9U96KOi2yE.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added \PYGZsq{}192.168.10.1\PYGZsq{} (RSA) to the list of known hosts.
root@qemuarm:\PYGZti{}\PYGZsh{}
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

La connexion via SSH a été validée et la commande à distance peut être ainsi réalisée.
\end{quote}


\subsection{Test de l'image sur la machine cible}
\label{developpement:test-de-l-image-sur-la-machine-cible}
Afin de créer une image pour la machine cible il faut modifier le fichier `'local.conf'`. La modification suivante a été réalisée en utilisant l'éditeur nano:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}MACHINE ?= \PYGZdq{}qemuarm\PYGZdq{}}
MACHINE ??\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}solidrun\PYGZhy{}imx6\PYGZdq{}}
\end{Verbatim}

La compilation a été faite à nouveau, puis elle a été montée sur une mémoire Micro SD. Tout d'abord, nous avons inséré une mémoire micro SD (en format ext4) et nous avons vérifié l'étiquette qui lui a été attribuée par le système d'exploitation.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}lsblk
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
mmcblk1     179:0    \PYG{l+m}{0}   7,3G  \PYG{l+m}{0} disk
\end{Verbatim}

Puis sur un autre terminal, l'environnement ``oe-init-build-env'' a été initialisé. Les commandes suivantes ont été utilisées pour monter l'image dans notre mémoire :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}cd} tmp/deploy/images/solidrun\PYGZhy{}imx6/
\PYGZdl{}zcat core\PYGZhy{}image\PYGZhy{}ubs\PYGZhy{}homeautomation\PYGZhy{}solidrun\PYGZhy{}imx6.wic.gz \PYG{p}{\textbar{}} sudo dd \PYG{n+nv}{of}\PYG{o}{=}/dev/mmcblk1  
\PYG{n+nv}{bs}\PYG{o}{=}4M \PYG{n+nv}{iflag}\PYG{o}{=}fullblock \PYG{n+nv}{oflag}\PYG{o}{=}direct \PYG{n+nv}{conv}\PYG{o}{=}fsync \PYG{n+nv}{status}\PYG{o}{=}progress
\end{Verbatim}

L’image a été correctement décompressée et place sur la mémoire MicroSd. Comme l'image créée, a son propre u-boot notre distribution est prête à être testée. Les tests qui ont été effectués étaient les suivants :
\begin{itemize}
\item {} 
Comme la carte hummingboard n’as pas d’écran pour travailler, la communication série a été utilisé. Premièrement, le câble série a été correctement configuré et connecté à la machine hôte, puis sur le terminal de la machine hôte nous avons lancé la ligne de commande suivante :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}sudo} screen /dev/ttyUSB0 1152000
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Cela nous a permis de créer un pont de communication machine hôte - machine cible.
\end{quote}
\begin{itemize}
\item {} 
Un fois le système démarré, la configuration d'IP de la machine cible était nécessaire. Les commandes suivantes ont été utilisées :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)} 2.4.4 qemuarm ttymxc0
solidrun\PYGZhy{}imx6 login: root
root@solidrun\PYGZhy{}imx6: \PYGZti{}\PYGZsh{}ifconfig eth0 192.168.10.1
Atheros \PYG{l+m}{8035} ethernet 2188000.ethernet\PYGZhy{}1:00:attached PHY driver \PYG{o}{[}
Atheros \PYG{l+m}{8035} ethernet\PYG{o}{]} \PYG{o}{(}mii\PYGZus{}bus:phy\PYGZus{}addr\PYG{o}{=}2188000.ethernet\PYGZhy{}1:00, \PYG{n+nv}{irq}\PYG{o}{=}\PYGZhy{}1\PYG{o}{)}
IPv6: ADDRCONF\PYG{o}{(}NETDEV\PYGZus{}CHANGE\PYG{o}{)}: eth0: link is not ready
root@solidrun\PYGZhy{}imx6:\PYGZti{}\PYGZsh{} fec 2188000.ethernet eth0: 
Link is Up – 100Mbps/Full – flow control rx/tx
IPv6: ADDRCONF\PYG{o}{(}NETDEV\PYGZus{}CHANGE\PYG{o}{)}: eth0: link becomes ready
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

De cette façon, deux communications machine hôte – machine cible sont disponibles. Le premier via série et le deuxième via SSH. Cependant la communication série sera utilisée plus tard pour envoyer les données du capteur Si7021 tandis que le SSH nous permettra de contrôler la machine cible à distance.
\end{quote}


\section{Création et compilation d'une application}
\label{developpement:creation-et-compilation-d-une-application}

\subsection{Création d'une application}
\label{developpement:creation-d-une-application}
Afin de mesurer l’humidité et la température de l’environnement, le capteur ``Adafruit Si7021'' a été employé. Le capteur utilise une communication I2C, quatre fils ont donc été utilisés SLA, SDA, Vcc et GND. Sur la machine cible nous avons fait le branchement de SLA-SLA, SDA-SDA, Vcc-3.3v (puisque le voltage d’opération est de 1.9V à 3.6V) et GND-GND.

Le programme de base a été obtenu sur le site \href{https://bit.ly/2T61t7S}{https://bit.ly/2T61t7S} , cependant certaines modifications ont été faites :
\begin{itemize}
\item {} 
Pour déterminer sur quel port de communication le capteur a été bronché, nous pouvons utiliser les commandes suivantes sur le terminal de communication SSH :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} i2cdetect 2
WARNING ! This program can confuse your I2C bus , cause data loss
and worse !
I will probe file / dev / i2c \PYGZhy{}2.
I will probe address range \PYG{l+m}{0} x03 \PYGZhy{}0 x77 .
43Continue ? \PYG{o}{[} Y / n \PYG{o}{]} Y
    \PYG{l+m}{0}   \PYG{l+m}{1}  \PYG{l+m}{2}  \PYG{l+m}{3}  \PYG{l+m}{4}  \PYG{l+m}{5}  \PYG{l+m}{6}  \PYG{l+m}{7}  \PYG{l+m}{8}  \PYG{l+m}{9}  a  b  c  d  e  f
00: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
10: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
20: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
30: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
40: \PYG{l+m}{40} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
50: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
60: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
70: \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Le port à utiliser sur le programme est donc ‘‘/dev/i2c-2’’. La modification faite sur le fichier .C a été le suivant :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
char *bus \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}/dev/i2c\PYGZhy{}2\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}
\end{quote}
\end{quote}
\begin{itemize}
\item {} 
Pour déterminer sur quel port de communication série le capteur doit afficher l’information, nous avons utilisé les commandes suivantes sur le terminal de communication SSH :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} dmesg \PYG{p}{\textbar{}} grep tty
kernel \PYG{n+nb}{command} line: \PYG{n+nv}{root}\PYG{o}{=}\PYG{n+nv}{PARTUUID}\PYG{o}{=}2024ca51\PYGZhy{}01 
root \PYG{n+nb}{wait} rw \PYG{n+nv}{console}\PYG{o}{=}ttymxc0, 115200
2020000.serial:ttymxc0 at MMIO 0x2020000\PYG{o}{(}\PYG{n+nv}{irq}\PYG{o}{=}27, 
\PYG{n+nv}{base\PYGZus{}baud}\PYG{o}{=}50000000\PYG{o}{)} is a IMX console \PYG{o}{[}ttymxc0\PYG{o}{]} enabled
21ec000.serial:ttymxc2 at MMIO 0x21ec000\PYG{o}{(}\PYG{n+nv}{irq}\PYG{o}{=}74, 
\PYG{n+nv}{base\PYGZus{}baud}\PYG{o}{=}50000000\PYG{o}{)} is a IMX
21f0000.serial:ttymxc3 at MMIO 0x21f0000\PYG{o}{(}\PYG{n+nv}{irq}\PYG{o}{=}75, 
\PYG{n+nv}{base\PYGZus{}baud}\PYG{o}{=}50000000\PYG{o}{)} is a IMX serial serial0: tty port ttymxc3 registered
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Le port série ttymxc0 est le seul disponible pour effectuer une communication série. Les modifications qui ont été prises en compte ont été la définition du port série, la configuration de la vitesse de communication, ainsi que certaines configurations d'un programme trouvé en ligne \href{https://bit.ly/2EPUooW}{https://bit.ly/2EPUooW}. Les modifications faites sur le fichier .C ont été les suivantes :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{fd} \PYG{o}{=} open\PYG{o}{(}\PYG{l+s+s2}{\PYGZdq{}/dev/ttymxc0\PYGZdq{}},O\PYGZus{}RDWR \PYG{p}{\textbar{}} O\PYGZus{}NOCTTY \PYG{p}{\textbar{}} O\PYGZus{}NDELAY\PYG{o}{)}\PYG{p}{;}
struct termios SerialPortSettings\PYG{p}{;}
tcgetattr\PYG{o}{(}fd, \PYG{p}{\PYGZam{}}SerialPortSettings\PYG{o}{)}\PYG{p}{;}
cfsetispeed\PYG{o}{(}\PYG{p}{\PYGZam{}}SerialPortSettings,B115200\PYG{o}{)}\PYG{p}{;}
cfsetospeed\PYG{o}{(}\PYG{p}{\PYGZam{}}SerialPortSettings,B115200\PYG{o}{)}\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}PARENB\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}CSTOPB\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}CSIZE\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\textbar{}}\PYG{o}{=}  CS8\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}CRTSCTS\PYG{p}{;}
SerialPortSettings.c\PYGZus{}cflag \PYG{p}{\textbar{}}\PYG{o}{=} CREAD \PYG{p}{\textbar{}} CLOCAL\PYG{p}{;}
SerialPortSettings.c\PYGZus{}iflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}\PYG{o}{(}IXON \PYG{p}{\textbar{}} IXOFF \PYG{p}{\textbar{}} IXANY\PYG{o}{)}\PYG{p}{;}
SerialPortSettings.c\PYGZus{}iflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}\PYG{o}{(}ICANON \PYG{p}{\textbar{}} ECHO \PYG{p}{\textbar{}} ECHOE \PYG{p}{\textbar{}} ISIG\PYG{o}{)}\PYG{p}{;}
SerialPortSettings.c\PYGZus{}oflag \PYG{p}{\PYGZam{}}\PYG{o}{=} \PYGZti{}OPOST\PYG{p}{;}
\end{Verbatim}
\end{quote}
\end{quote}
\begin{itemize}
\item {} 
Le programme de base affiche les données d’humidité et de température qu'une seule fois. Cependant il est nécessaire que l’information soit affichée en permanence, c'est pourquoi une boucle a été utilisée pour faire défiler le processus d'acquisition des informations du capteur et d'affichage des informations.

\item {} 
L'information obtenue par les capteurs est stockée dans une variable numérique, mais pour être transmise en série, ces valeurs doivent être transformées en un format de caractère. Les lignes suivantes ont été ajoutées sur le fichier .C :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
sprintf\PYG{o}{(}humi,\PYG{l+s+s2}{\PYGZdq{}Humidity : \PYGZpc{}.2f \PYGZdq{}},humidity\PYG{o}{)}\PYG{p}{;}
sprintf\PYG{o}{(}ct,\PYG{l+s+s2}{\PYGZdq{}Temp : \PYGZpc{}.2f \PYGZbs{}n\PYGZbs{}r \PYGZdq{}},cTemp\PYG{o}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

\item {} 
Finalement, les données sont envoyées par le port série. Une commande a été utilisée pour indiquer le port où les données seront envoyées, la taille du message et le message. Les modifications suivantes ont été ajoutées sur le fichier .C :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{bytes\PYGZus{}written} \PYG{o}{=} write\PYG{o}{(}fd,humi,sizeof\PYG{o}{(}humi\PYG{o}{)}\PYG{o}{)}\PYG{p}{;}
\PYG{n+nv}{bytes\PYGZus{}written} \PYG{o}{=} write\PYG{o}{(}fd,ct,sizeof\PYG{o}{(}ct\PYG{o}{)}\PYG{o}{)}\PYG{p}{;}
\end{Verbatim}
\end{quote}

\end{itemize}

Un fois le programme soit correctement complété, le système pourra donc lire les données (température et humidité) du capteur Si7021 à intervalle de temps régulier et d’afficher le résultat de la lecture sur le port série UART.


\subsection{Compilation d'une application}
\label{developpement:compilation-d-une-application}
Une compilation spéciale a été faite, puisqu'elle doit inclure toutes les fonctionnalités de notre machine cible, nous avons donc utilisé l'outil SDK que Yocto incorpore. L’outil SDK est un standard qui comprend les éléments suivants :
\begin{itemize}
\item {} 
Chaîne d'outils de développement croisé.

\item {} 
Bibliothèques en-têtes et symboles.

\item {} 
Script de configuration de l'environnement.

\end{itemize}

Avec le SDK nous pouvons développer et tester indépendamment le code destiné à fonctionner sur une machine cible. Nous partons de la basse que nous avons déjà initialisé l’environnement (source oe-init-build-env) et nous somme sur le dossier /poky/build:
\begin{itemize}
\item {} 
Puis nous avons utilisé la ligne de commande suivante pour créer le SDK:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
bitbake meta\PYGZhy{}toolchain
\end{Verbatim}
\end{quote}

\item {} 
Pour installer correctement le SDK, nous avons exécuté le fichier.sh et nous avons suivi les instructions :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} tmp/deploy/sdk
\PYGZdl{} sudo ./poky\PYGZhy{}glibc\PYGZhy{}x86\PYGZus{}64\PYGZhy{}meta\PYGZhy{}toolchain\PYGZhy{}cortexa9hf\PYGZhy{}neon\PYGZhy{}toolchain \PYGZhy{}2.4.4.sh
Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)} SDK installer version 2.4.4
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
Enter target directory \PYG{k}{for} SDK \PYG{o}{(}default: /opt/poky/2.4.4\PYG{o}{)}:
The directory \PYG{l+s+s2}{\PYGZdq{}/opt/poky/2.4.4\PYGZdq{}} already contains a SDK \PYG{k}{for} this architecture.
If you \PYG{k}{continue}, existing files will be overwritten! Proceed\PYG{o}{[}y/N\PYG{o}{]}? y
Extracting SDK......................done
Setting it up...done
SDK has been successfully \PYG{n+nb}{set} up and is ready to be used.
Each \PYG{n+nb}{time} you wish to use the SDK in a new shell session, you need to \PYG{n+nb}{source} 
the environment setup script e.g.
 \PYGZdl{} . /opt/poky/2.4.4/environment\PYGZhy{}setup\PYGZhy{}armv5e\PYGZhy{}poky\PYGZhy{}linux\PYGZhy{}gnueabi
 \PYGZdl{} . /opt/poky/2.4.4/environment\PYGZhy{}setup\PYGZhy{}cortexa9hf\PYGZhy{}neon\PYGZhy{}poky\PYGZhy{}linux\PYGZhy{}gnueabi
\end{Verbatim}
\end{quote}

\item {} 
Le SDK a été correctement installé. Cependant pour compiler notre application il faut initialiser l’environnement ``environment-setup-cortexa9hf-neon-poky-linux-gnueabi''. Dans un autre terminal, nous avons occupé les commandes suivantes afin d'initialiser et compiler notre application :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}cd} /opt/poky/2.4.4
\PYG{n+nb}{source} environment\PYGZhy{}setup\PYGZhy{}cortexa9hf\PYGZhy{}neon\PYGZhy{}poky\PYGZhy{}linux\PYGZhy{}gnueabi
\PYG{n+nb}{cd} /home/...\PYG{o}{[}Adrese ou il se trouve le fichier a compiler\PYG{o}{]}…../
\PYG{n+nv}{\PYGZdl{}CC} \PYGZhy{}o HTS HTSERIAL.c
\end{Verbatim}
\end{quote}

\end{itemize}

Notre application HTSERIAL.c a été correctement compilé. Pour être testé sur la machine cible, il est nécessaire d'envoyer le document HTS. Le système de transfert de fichiers utilisé était la communication SSH et la commande `'copie'`. Les étapes à suivre pour envoyer et tester l'application sont les suivantes :
\begin{itemize}
\item {} 
Afin d’envoyer l’application, nous avons défini le fichier source et le dossier du destine. Sur un nouveau terminal la commande suivante a donc été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}sudo scp \PYGZhy{}r \PYGZhy{}p HTS root@192.168.10.1:/home/ubs/.
\end{Verbatim}
\end{quote}

\item {} 
Sur la terminal SSH de notre machine cible, nous avons exécuté l’application de la façon suivante :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} \PYG{n+nb}{cd} /
root@solidrun \PYGZhy{} imx6 :/\PYGZsh{} \PYG{n+nb}{cd} /home/ubs
root@solidrun \PYGZhy{} imx6 :/home/ubs\PYGZsh{}  ./HTS
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Immédiatement sur le terminal série, il commencera à afficher des informations sur l'humidité {[}Humidity{]} et la température {[}Temp{]} de l’environnement.
\end{quote}


\section{Création et initialisation d’un service}
\label{developpement:creation-et-initialisation-dun-service}
L’application peut être exécuté au démarrage du système, puisque notre distribution utilise le Systemd. La structure du service est simple, dans une première partie nous devons décrire le service, puis indique la tâche à exécuter, finalement nous devons indiquer le ‘‘target’’ où le service sera actif. Le fichier.service réalisé est le suivant :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{[}Unit\PYG{o}{]}
\PYG{n+nv}{Description}\PYG{o}{=}HTS\PYGZhy{} Temperature et Humidite \PYGZhy{} Agent

\PYG{o}{[}Service\PYG{o}{]}
\PYG{n+nv}{Type}\PYG{o}{=}idle
\PYG{n+nv}{ExecStart}\PYG{o}{=}/usr/libexec/HTS

\PYG{o}{[}Install\PYG{o}{]}
\PYG{n+nv}{WantedBy}\PYG{o}{=}multi\PYGZhy{}user.target
\end{Verbatim}

Le fichier service ‘‘HTS-service.service’’et le fichier ‘‘HTS’’ doivent être placés aux bons endroits pour leur exécution. Les étapes suivantes ont été suivies pour activer un service dans notre distribution :
\begin{itemize}
\item {} 
Le fichier .service a été placé sur le dossier du Systemd. L’application a été placé sur le dossier /usr/libexec. Les suivantes commandes ont donc été utilisées :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}sudo scp \PYGZhy{}r \PYGZhy{}p HTS\PYGZhy{}service.service root@192.168.10.1:/etc/systemd/system/.
\PYGZdl{}sudo scp \PYGZhy{}r \PYGZhy{}p HTS root@192.168.10.1:/usr/libexec/.
\end{Verbatim}

\begin{notice}{note}{Note:}
Sur le dossier /usr/libexec sont placés les binaires internes qui ne sont pas destinés à être exécutés directement par les utilisateurs ou les scripts shell.
\end{notice}
\end{quote}

\item {} 
Sur la terminal SSH de notre machine hôte, nous avons exécuté le service de la façon suivante :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} systemctl \PYG{n+nb}{enable} HTS\PYGZhy{}service.service.service
\end{Verbatim}
\end{quote}

\end{itemize}
\begin{quote}

Ceci exécutera notre service à chaque fois que notre système démarre. Cependant si à tout moment nous voulons arrêter le service, la commande suivante peut être utilisée :
\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
        Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)} 2.4.4 qemuarm tty
        qemuarm login: root
        root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} systemctl stop HTS\PYGZhy{}service.service.service

\end{Verbatim}

\begin{notice}{note}{Note:}
Comme le service s\PYG{l+s+s1}{\PYGZsq{}exécute lorsque le système d\PYGZsq{}}exploitation a été initialisé, il peut être difficile de placer les lignes de commande.
\end{notice}


\section{Démarrage d'un distribution Linux via Emmc}
\label{developpement:demarrage-d-un-distribution-linux-via-emmc}
La mémoire emmc est un endroit de stockage de la carte hummingboard, dans laquelle le système d'exploitation peut être introduit dans le but de ne pas dépendre d'une mémoire Micro SD. Cependant pour que le système d'exploitation puisse être installé dans la mémoire emmc, un autre système d'exploitation est nécessaire, puisqu’il nous permet de gérer les éléments matériels de l’architecture sur laquelle il est hébergé. Les étapes suivantes ont été utilisées pour sauvegarder notre distribution dans la mémoire emmc :
\begin{itemize}
\item {} 
Dans une mémoire USB l'image ``core-image-ubs-homeautomation-solidrun-imx6.wic.gz'' a été sauvegardée. Puis la mémoire a été insérée dans la machine cible. Afin d’accéder à tout l’information de la mémoire USB nous avons exécuté la commande suivante :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} mount  /dev/sda /mnt/
\end{Verbatim}
\end{quote}

\item {} 
Avant de monter l'image sur une partition, nous avons vérifié le nom de la partition. La commande suivante a été utilisée :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} fdisk \PYGZhy{}l
\end{Verbatim}
\end{quote}

\item {} 
Dans la liste qui est affichée, nous pouvons observer que la partition mmcblk2 est la plus grande et c'est là que notre système d'exploitation peut fonctionner. Une fois le nom de la partition validé, l'image était montée sur cette partition.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 : :\PYGZti{}\PYGZsh{} \PYG{n+nb}{cd} /mnt
root@solidrun \PYGZhy{} imx6 :/mnt\PYGZsh{} zcat core\PYGZhy{}image\PYGZhy{}ubs\PYGZhy{}homeautomation\PYGZhy{}solidrun\PYGZhy{}imx6
.wic.gz\PYG{p}{\textbar{}} sudo dd \PYG{n+nv}{of}\PYG{o}{=}/dev/mmcblk2
167936+0 records in
167936+0 records out
\end{Verbatim}
\end{quote}

\item {} \begin{description}
\item{Pour que le système puisse démarrer avec le mode emmc ou le mode Micro Sd, 
les jumpers doivent être placées comme suit :} \leavevmode\begin{itemize}
\item {} 
Emmc : 3 jumpers seront utilisées : (1+2), (3+4), (7+8)

\item {} 
MicroSD : 2 jumpers seront utilisées : (3+4), (5+6)

\end{itemize}

\end{description}

\end{itemize}
\begin{quote}

Lors de l'initialisation en mode emmc, un message d'erreur Panic Kernel apparaît. Nous devons donc revenir à la configuration Micro SD et exécuter les commandes suivantes :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} mount  \PYGZhy{}t ext4 /dev/mmcblk2p1 /mnt/
root@solidrun \PYGZhy{} imx6 :\PYGZti{}\PYGZsh{} \PYG{n+nb}{cd} /mnt
root@solidrun \PYGZhy{} imx6 :/mnt\PYGZsh{} \PYG{n+nb}{cd} boot/extlinux
root@solidrun \PYGZhy{} imx6 :/mnt/boot/extlinux\PYGZsh{} vi extlinux.conf
\end{Verbatim}
\end{quote}

Cela nous permet de monter la partition mmcblk2p1 où notre distribution a été sauvegardée, avec le but de réaliser une modification au document extlinux.conf en utilisant l'éditeur Vi. Sur l'éditeur nous pouvons modifier le fichier en utilisant la touche ‘i’. Nous devons modifier le fichier comme suit :
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Generic Distro Configuration file generated by OpenEmbedded}
LABEL Poky \PYG{o}{(}Yocto Project Reference Distro\PYG{o}{)}
  KERNEL ../zImage
  FDTDIR  ../
  APPEND \PYG{n+nv}{root}\PYG{o}{=}/dev/mmcblk2p1 rootwait rw \PYG{n+nv}{console}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{console}\PYG{l+s+si}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Pour finaliser le mode d’édition nous devons appuyer la touche ‘esc’ et puis les touches ‘w’ et ‘q’ pour enregistrer et quitter.
\end{quote}

La configuration des `Jumpers' doit être replacée en mode emmc et le système peut être démarré sur la mémoire interne de la machine cible. Les étapes précédentes (2.5 et 2.6) doivent être répétées, car tout ce qui a été effectué a été stocké dans la mémoire Micro SD.


\chapter{Resultats}
\label{resultats::doc}\label{resultats:resultats}
Comme toutes les étapes ont été correctement exécutées (2.1-2.6), le système fonctionne comme suit: \href{https://photos.app.goo.gl/7eKJKSoa1xxFsHw78}{https://photos.app.goo.gl/7eKJKSoa1xxFsHw78}

Pour arrêter le service, le process suivante doit être effectuée : \href{https://photos.app.goo.gl/MLTC3iRKNcBNKVth9}{https://photos.app.goo.gl/MLTC3iRKNcBNKVth9}

Lorsque l'image est enregistrée dans la mémoire emmc et que la configuration des `'Jumpers'' est effectuée, le message d'erreur suivant s'affiche:

{\hspace*{\fill}\includegraphics[scale=0.2]{{kernel}.png}\hspace*{\fill}}

Pour corriger l'erreur, il est nécessaire de changer la position des `'Jumpers'' et d'effectuer les changements décrits précédemment (2.7). Le système se chargera complètement depuis la mémoire emmc sans avoir besoin de la carte micro SD:

{\hspace*{\fill}\includegraphics[scale=0.2]{{emmc}.png}\hspace*{\fill}}


\chapter{Conclusions}
\label{conclusion:conclusions}\label{conclusion::doc}
La réalisation de ce projet peut être comparé au projet SESI, puisque le niveau d'effort a aussi été élevé. Si bien, la création de l'image et la recette n'a été pas difficile, tous les sujets autour le projet l’ont été. Surtout parce que c'était la première fois dans ma vie que j'ai utilisé Linux. Quelques exemples des difficultés rencontrées étaient quelques commandes pour configurer l'adresse IP de la machine cible et la machine hôte, la connexion SSH, l’envoie des documents via SSH, l’édition des documents en mode vi et monter des mémoires externes.

Un autre exemple qui a également pris du temps a été la communication I2C et série sur la carte hummingboard, puisque je n'avais pas programmé ce type de communication dans un environnement Linux et en utilisant du code C.

Le principal défi du développement du projet a été de sauvegarder l’image de notre distribution dans la mémoire emmc. Si bien la procédure n’était pas difficile, certains détails doivent être considérés comme la configuration des `jumpers'. Parce que si la configuration n’est pas bien faite l’OS jamais va démarrer via l’emmc, après de nombreuses essayes j’ai trouvé la légende suivante pendant le démarrage : ``la partition emmc ne pouvait pas être initialisée'', ce message m’a permis de comprendre l’erreur possible et dans la documentation de la carte, j'ai trouvé la configuration de ‘Jumpers’ nécessaires pour démarrer le système comme nous souhaitons. Par conséquent, une conclusion est de toujours avoir les manuels et fiches techniques des systèmes, puisque la source d'information est fiable et parceque en général ils contiennent toutes les informations nécessaires pour développer nos projets.

Si bien j'ai reussi de stocker l'image dans l'emmc, je n'avais pas le temps d'effectuer la détection de température et d'humidité, comme je l'avais fait dans la micro SD. L'emmc était la dernière exigence que j'avais fait et je n'ai eu plus le temps de la perfectionner. Certaines améliorations peuvent être apportées dans le travail, par exemple la modification de la recette, afin de compiler l'application, installer et démarrer le service et d’attribuer une adresse IP a la machine cible. De cette façon, notre image pourrait être reproduite pour un grand nombre de cartes de développement.

Finalement, tous les défis trouvés m'ont aidé à comprendre le fonctionnement de l'outil Yocto Project. J'ai appris de nouvelles commandes, et surtout je peux vous assurer que mes compétences dans l'environnement Linux ont considérablement progressé.


\chapter{Références}
\label{references::doc}\label{references:references}\begin{itemize}
\item {} 
de Yocto rocko mega manuel \href{https://www.yoctoproject.org/docs/2.4.3/mega-manual/mega-manual.html}{https://www.yoctoproject.org/docs/2.4.3/mega-manual/mega-manual.html}

\item {} 
de Yocto \href{https://wiki.solid-run.com/doku.php?id=products:imx6:software:os:yocto}{https://wiki.solid-run.com/doku.php?id=products:imx6:software:os:yocto}

\item {} 
du manuel de Bitbake \href{https://www.yoctoproject.org/docs/2.4.3/bitbake-user-manual/bitbake-user-manual.html}{https://www.yoctoproject.org/docs/2.4.3/bitbake-user-manual/bitbake-user-manual.html}

\item {} 
de Rocko \href{https://layers.openembedded.org/layerindex/branch/rocko/layers/}{https://layers.openembedded.org/layerindex/branch/rocko/layers/}

\item {} 
de Solid-Run \href{https://wiki.solid-run.com/doku.php?id=products:imx6:software:os:yocto}{https://wiki.solid-run.com/doku.php?id=products:imx6:software:os:yocto}

\item {} 
de Freescale \href{https://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/about/}{https://git.yoctoproject.org/cgit/cgit.cgi/meta-fsl-arm/about/}

\item {} 
de la FSL Community BSP : \href{http://freescale.github.io/}{http://freescale.github.io/}

\item {} 
de la machine Cible \href{https://wiki.solid-run.com/doku.php?id=products:imx6:hummingboard}{https://wiki.solid-run.com/doku.php?id=products:imx6:hummingboard}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
